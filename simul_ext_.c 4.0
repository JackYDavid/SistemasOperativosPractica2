#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include "cabeceras.h"

#define LONGITUD_COMANDO 100

void Printbytemaps(EXT_BYTE_MAPS *ext_bytemaps);
int ComprobarComando(char *strcomando, char *orden, char *argumento1, char *argumento2);
void LeeSuperBloque(EXT_SIMPLE_SUPERBLOCK *psup);
int BuscaFich(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos,
              char *nombre);
void Directorio(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos);
int Renombrar(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos,
              char *nombreantiguo, char *nombrenuevo);
int Imprimir(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos,
             EXT_DATOS *memdatos, char *nombre);
int Borrar(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos,
           EXT_BYTE_MAPS *ext_bytemaps, EXT_SIMPLE_SUPERBLOCK *ext_superblock,
           char *nombre,  FILE *fich);
int Copiar(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos,
           EXT_BYTE_MAPS *ext_bytemaps, EXT_SIMPLE_SUPERBLOCK *ext_superblock,
           EXT_DATOS *memdatos, char *nombreorigen, char *nombredestino, FILE *fich);
void Grabarinodosydirectorio(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos, FILE *fich);
void GrabarByteMaps(EXT_BYTE_MAPS *ext_bytemaps, FILE *fich);
void GrabarSuperBloque(EXT_SIMPLE_SUPERBLOCK *ext_superblock, FILE *fich);
void GrabarDatos(EXT_DATOS *memdatos, FILE *fich);

int main(){
	 char comando[LONGITUD_COMANDO];
	 char orden[LONGITUD_COMANDO];
	 char argumento1[LONGITUD_COMANDO];
	 char argumento2[LONGITUD_COMANDO];

	 int i,j;
	 unsigned long int m;
     EXT_SIMPLE_SUPERBLOCK ext_superblock;
     EXT_BYTE_MAPS ext_bytemaps;
     EXT_BLQ_INODOS ext_blq_inodos;
     EXT_ENTRADA_DIR directorio[MAX_FICHEROS];
     EXT_DATOS memdatos[MAX_BLOQUES_DATOS];
     EXT_DATOS datosfich[MAX_BLOQUES_PARTICION];
     int entradadir;
     int grabardatos;
     FILE *fent;

     // Lectura del fichero completo de una sola vez
     fent = fopen("particion.bin", "r+b");
     fread(&datosfich, SIZE_BLOQUE, MAX_BLOQUES_PARTICION, fent);


     memcpy(&ext_superblock,(EXT_SIMPLE_SUPERBLOCK *)&datosfich[0], SIZE_BLOQUE);
     memcpy(&directorio,(EXT_ENTRADA_DIR *)&datosfich[3], SIZE_BLOQUE);
     memcpy(&ext_bytemaps,(EXT_BLQ_INODOS *)&datosfich[1], SIZE_BLOQUE);
     memcpy(&ext_blq_inodos,(EXT_BLQ_INODOS *)&datosfich[2], SIZE_BLOQUE);
     memcpy(&memdatos,(EXT_DATOS *)&datosfich[4], MAX_BLOQUES_DATOS*SIZE_BLOQUE);



   // Bucle de tratamiento de comandos
     for (;;){
		 do {
		 printf (" >> ");
		 fflush(stdin);
		 fgets(comando, LONGITUD_COMANDO, stdin);
		 } while (ComprobarComando(comando, orden, argumento1, argumento2) != 0);
	     if (strcmp(orden, "dir") == 0) {
            Directorio(&directorio,&ext_blq_inodos);
            continue;
        }
        else if(strcmp(orden, "info") == 0){
                LeeSuperBloque(&ext_superblock);
        }
        else if(strcmp(orden, "imprimir") == 0){
                Imprimir(directorio, &ext_blq_inodos, datosfich, argumento1);
        }
        else if (strcmp(orden,"bytemaps") == 0) {
                Printbytemaps(&ext_bytemaps);
        }
        else if (strcmp(orden,"rename") == 0) {
                Renombrar(directorio, &ext_blq_inodos, argumento1, argumento2);
        }

         // Escritura de metadatos en comandos rename, remove, copy
         //Grabarinodosydirectorio(&directorio,&ext_blq_inodos,fent);
         //GrabarByteMaps(&ext_bytemaps,fent);
         //GrabarSuperBloque(&ext_superblock,fent);
         //if (grabardatos)
           //GrabarDatos(&memdatos,fent);
         //grabardatos = 0;
         //Si el comando es salir se habrán escrito todos los metadatos
         //faltan los datos y cerrar
         if (strcmp(orden,"salir")==0){
            //GrabarDatos(&memdatos,fent);
            fclose(fent);
            return 0;
         }
     }
}

//COMANDO INFO
void LeeSuperBloque(EXT_SIMPLE_SUPERBLOCK *psup){

    //Muestra la información del superbloque por pantalla
    printf("El bloque tiene %d bytes \n", psup->s_block_size);
    printf("Inodos particion = %d \n", psup->s_inodes_count);
    printf("inodos libres = %d \n", psup->s_free_inodes_count);
    printf("Bloques particion = %d \n", psup->s_blocks_count);
    printf("Bloques libres = %d \n", psup->s_free_blocks_count);
    printf("Primer bloque de datos = %d \n", psup->s_first_data_block);

}

//COMANDO BYTEMAPS
void Printbytemaps(EXT_BYTE_MAPS *ext_bytemaps){

    //Muestra el contenido del bytemap de inodos
    printf("Inodos :");
    int i;
    for(i = 0; i < MAX_INODOS; i++){
        printf("%d", ext_bytemaps->bmap_inodos[i]);
    }

    //Muestra los primeros 25 elementos delbytemap de bloques
    printf("\nBloques [0-25]: ");
    for(i = 0; i < 25; i++){
        printf("%d", ext_bytemaps->bmap_bloques[i]);
    }
    printf("\n");
}



//COMANDO RENOMBRAR
int Renombrar(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos, char *nombreantiguo, char *nombrenuevo){

    short unsigned int comprobar = 0;
    short unsigned int wardI;
    int i;

    //Cambia el nombre de un fichero a la entrada correspondiente
    for(i = 1; ((directorio+i)->dir_inodo)!=NULL_INODO; i++){
        if((strcmp(nombreantiguo, (directorio+i)->dir_nfich) == 0)){
            comprobar++;
            wardI = i;
        }
        if(strcmp(nombrenuevo,(directorio+i)->dir_nfich) == 0){
            return -1;
        }
    }

    //Comprobamos que el fichero origen existe
    if(comprobar = 1){
        strcpy((directorio+wardI)->dir_nfich, nombrenuevo);
    }

    return comprobar;
}



//COMPROBAR COMANDO
int ComprobarComando(char *strcomando, char *orden, char *argumento1, char *argumento2){

    //VACIAMOS LOS COMANDOS
    strcpy(orden, "");
    strcpy(argumento1, "");
    strcpy(argumento2, "");

    char temp[strlen(strcomando)];
    strncpy(temp, strcomando, strlen(strcomando)-1);
    temp[strlen(strcomando)-1] = '\0';
    char *token = strtok(temp, " ");

    //DIVIDIR EL COMANDO
    if(token != NULL){
        int i;
        for(i = 0; token != NULL; i++){

            switch(i){


                case 0:
                        strcpy(orden, token);
                        token = strtok(NULL," ");
                        break;

                case 1:
                        strcpy(argumento1, token);
                        token = strtok(NULL," ");
                        break;

                case 2:
                        strcpy(argumento2, token);
                        token = strtok(NULL," ");
                        break;

                default:
                        return 1;
            }
        }

    }else{
        return 1;
    }
    if(strcmp(orden,"info") == 0){
        return 0;
    }else if(strcmp(orden, "bytemaps") == 0){
        return 0;
    }else if(strcmp(orden, "dir") == 0){
        return 0;
    }else if(strcmp(orden, "rename") == 0){
        return !(strlen(argumento1) > 0 && strlen(argumento2) > 0);
    }else if(strcmp(orden, "imprimir") == 0){
        return !(strlen(argumento1) > 0);
    }
}



//COMANDO DIR, cuidado! peta al escribirlo pero sale la información
void Directorio(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos){

    //Lista todos los ficheros
    int i,j;
    for(i=1;MAX_FICHEROS;i++){
        if((directorio+i)->dir_inodo!=0){

            // Mostramos nombre, tamaño, inodo y bloques que ocupa
            printf("%s\ttamaño: %d\tinodo: %d\tbloques:",(directorio+i)->dir_nfich, inodos->blq_inodos[(directorio+i)->dir_inodo].size_fichero, (directorio+i)->dir_inodo);
            for(j = 0; inodos ->blq_inodos[(directorio+i)->dir_inodo].i_nbloque[j]!=NULL_INODO;j++){

                    printf("%d", inodos->blq_inodos[(directorio+i)->dir_inodo].i_nbloque[j]);
            }
            printf("\n");
        }
    }
}




//COMANDO IMPRIMIR
int Imprimir(EXT_ENTRADA_DIR *directorio, EXT_BLQ_INODOS *inodos, EXT_DATOS *memdatos, char *nombre){
	//Primero comprobamos si existe el fichero pedido
	short unsigned int comprobar = 0;
	short unsigned int wardI;

	for(int i = 1; ((directorio+i)->dir_inodo)!=NULL_INODO; i++){
		if((strcmp(nombre, (directorio+i)->dir_nfich ) == 0)){
			comprobar++;
			wardI = i;
			continue;
		}
	}

    //Muestra el contenido del fichero especificado como uin texto
	if(comprobar){
		for(int i = 0; inodos->blq_inodos[(directorio+wardI)->dir_inodo].i_nbloque[i]!=NULL_INODO; i++){
			unsigned char var[SIZE_BLOQUE];
			memcpy(var, memdatos[inodos->blq_inodos[(directorio+wardI)->dir_inodo].i_nbloque[i]].dato, SIZE_BLOQUE);
			var[SIZE_BLOQUE] = '\0';
			printf("%s", var);
		}
		printf("\n");
	}
    else {
        printf("No se encontro el archivo!(o no existe)");
    }
    printf("\n");

	return 1;
}
